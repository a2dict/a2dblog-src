---
title: Go元编程
tags:
  - 编程
  - 随笔
date: 2020-05-16 22:09:09
---


Wikipedia上对元编程的定义为

> Metaprogramming is a programming technique in which computer programs have the ability to treat other programs as their data. 
> -- [Metaprogramming - Wikipedia][1]

## 为什么需要元编程

如果说编程是用*代码*抽象*现实问题*，把*问题*转换成可运行的*代码*，进而用*计算*模拟现实。
那元编程就是用*代码*进一步抽象*代码*。

在编程时，我们从现实问题中寻找*模式*，构建代码抽象。
面对复杂问题时，代码可能显现出某种*模式*，而**元编程**提供了一种处理代码模式并构建进一步抽象的能力。

<!-- more -->
### 举个粟子

元编程的实现方式主要有两种：
- Macro（一般为编译时。代表：Rust、Clojure）
- 元数据和方法拦截（运行时。代表：Ruby）

在HTTP协议中，GET|POST|PUT等方法报文相似，可以应用Macro模板化方法定义。
这是[HttpKit][3]的客户端代码

```clj
;; 定义HTTP方法模板
(defmacro ^:private defreq [method]
  `(defn ~method
     ~(str "Issues an async HTTP " (str/upper-case method) " request. "
           "See `request` for details.")
     ~'{:arglists '([url & [opts callback]] [url & [callback]])}
     ~'[url & [s1 s2]]
     (if (or (instance? clojure.lang.MultiFn ~'s1) (fn? ~'s1) (keyword? ~'s1))
       (request {:url ~'url :method ~(keyword method)} ~'s1)
       (request (merge ~'s1 {:url ~'url :method ~(keyword method)}) ~'s2))))

(defreq get)
(defreq delete)
(defreq head)
(defreq post)
;; etc ...
;; btw, 这里其实可以进一步简化成 (defhttpreqs get delete head ... )
```

## Go元编程

优秀的程序员应该**Programming into Language**，而非**in Language**。
Go不原生支持元编程，没有Macro机制，反射能力很弱且存在性能问题，但这并不妨碍实现元编程。
好在Go原生提供了AST和Generate工具，可用于编译前生成代码。

### 原理
`go generate`会扫描源码以下格式注释
```go
//go:generate command argument...
```
并执行命令`command argument...`

官方提供[示例](https://blog.golang.org/generate)
```go
package painkiller

//go:generate stringer -type=Pill
type Pill int

const (
    Placebo Pill = iota
    Aspirin
    Ibuprofen
    Paracetamol
    Acetaminophen = Paracetamol
)
```

运行以下命令
```
$ go get golang.org/x/tools/cmd/stringer
$ go generate
```

会生成`pill_string.go`文件，为`Pill`类型实现`String()`方法

```
// Code generated by stringer -type Pill pill.go; DO NOT EDIT.

package painkiller

import "fmt"

const _Pill_name = "PlaceboAspirinIbuprofenParacetamol"

var _Pill_index = [...]uint8{0, 7, 14, 23, 34}

func (i Pill) String() string {
    if i < 0 || i+1 >= Pill(len(_Pill_index)) {
        return fmt.Sprintf("Pill(%d)", i)
    }
    return _Pill_name[_Pill_index[i]:_Pill_index[i+1]]
}
```

分析：`stringer`基于`go/ast`解析代码并生成目标代码，[源码这里][5]。

（这是不打算展开`go/ast`，下次再水一篇..）

Go提供了些实用的[代码生成工具][4]，其中用得最多是`deep-copy`、`go-syncmap`。

### Go Generage示例

#### 示例一 deep-copy

deep-copy 为结构体生成`DeepCopy()`方法——返回结构体的深拷贝。

在编程中，当结构体作为参数在多个函数间传递，很难确保调用过程中不被修改，从而导致副作用。
使用深拷贝对象（结构体）作为传递参数是常用的处理方式，尤其在非纯函数式编程（non-pure fp, eg: scala、rust）中很常见。

使用示例
```go
//go:generate deep-copy -o foo_deepcopy.go --type Foo .
type Foo struct {
    Name string
    M    map[string]string
    L    []string
}
```

运行命令
```
$ go get github.com/globusdigital/deep-copy 
$ go generate ./...
```

#### 示例二 go-syncmap

Go没有泛型，所以很多通用容器只能使用`interface{}`作为参数类型。

这样，当我们使用容器类时，处理方式上有两种选择
1. 直接使用容器类，以`interface{}`为参数，**人肉类型检查**
2. 将容器类包装成**类型化**容器
  
我更支持第二种方式。原因有
1. 程序员都是不靠谱的，企图让他们正确做好*类型检查*，太不现实了；
2. 如果一件事计算机和人都可以做，那就应该交给计算机，比如这里的*类型检查*；

采用方式二需要编写很多“模板代码”，而**go-syncmap**就是这么一个代码生成器，它部分弥补了Go由于缺少泛型而在通用容器上表达力不足。

```
// 注意 Pill<int,*time.Time> 中间不允许有空格！！
//go:generate go-syncmap -type Pill<int,*time.Time>
type Pill sync.Map
```

运行命令
```
$ go get github.com/searKing/golang/tools/cmd/go-syncmap
$ go generate ./...
```

我们就生成了
```
func (m *Pill) Store(key int, value time.Time)
func (m *Pill) LoadOrStore(key int, value time.Time) (time.Time, bool)
func (m *Pill) Load(key int) (time.Time, bool)
func (m *Pill) Delete(key int)
func (m *Pill) Range(f func(key int, value time.Time) bool
```


## 总结

元编程是一组操作代码的技术集合。

按作用的时期划分，可以分为1) 编译期静态元编程和2)运行时动态元编程；
按语言是否提供元编程能力，可以分为1)内部元编程和2)外部元编程；
事实上，现代编程语言或多或少都具有部分**内部元编程**能力，并支持实现**内部DSL**。

不支持内部元编程的语言，也可能通过regex、lex/yacc、ast等工具解析源码，以代码生成器的方式实现元编程。

元编程，是区分一般程序员与进阶程序员的一项重要技术。
直到哪天，将元编程深深融入程序设计中——“根本就没有元编程，有的只是编程而已”






## 引用&扩展
- [Metaprogramming - Wikipedia][1]
- [谈元编程与表达能力][2]
- [HttpKit Client源码][3]
- [GoGenerateTools][4]
- [stringer源码][5]

[1]: https://en.wikipedia.org/wiki/Metaprogramming "Metaprogramming - Wikipedia"
[2]: https://draveness.me/metaprogramming/ "谈元编程与表达能力"
[3]: https://github.com/http-kit/http-kit/blob/master/src/org/httpkit/client.clj#L297 "HttpKit"
[4]: https://github.com/golang/go/wiki/GoGenerateTools "GoGenerateTools"
[5]: https://github.com/golang/tools/blob/master/cmd/stringer/stringer.go "stringer源码"